(* Identifiers *)

<ident>    ::= ident
<generic>  ::= quote <ident>

(* Literals and initializers 

- Use semicolon as seperator for lists and records, but it is optional as newlines suffice.

*)

<integer>  ::= lit_int
<string>   ::= lit_str
<float>    ::= lit_float
<list>     ::= lbracket nl* (<expr> (comma nl* <expr>)* comma?)? nl* rbracket
<fieldval> ::= <ident> colon <expr>
<record>   ::= lbrace nl* (<fieldval> (comma nl* <fieldval>)* comma?)? nl* rbrace
<tuple>    ::= <expr> (comma <expr>)+
<literal>  ::= <integer> | <float> | <string> | <list> | <record> | <tuple>


(* Types *)

<type_list>   ::= lbracket <type> rbracket

<type_field>  ::= <ident> colon <type>
<type_record> ::= lbrace nl* (<type_field> (comma nl* <type_field>)* comma?)? nl* rbrace

<type_fn>     ::= <type> thinarrow <type>

<type>        ::= <path>
                | <generic>
                | <type_fn>
                | <type_list>
                | <type_record>
                | <type_union>
                | lparen <type> rparen

<type_union>  ::= <type_union> pipe <type_tuple>

<type_tuple>  ::= <type_tuple> star <type>


(* Expressions, generally ordered by precedence.

- Call binds stronger than unary
- Bash function call semantics (call first, everything else is an argument in the same expressions!)

- No, use <| and |> instead. :)

- Assignments bind weaker than everything but ref
- Ref binds the weakest.

 *)

<spec>   ::= lt <generic> (comma <generic>)* comma? gt

<path>   ::= <ident> (coloncolon <ident>)* <spec>?

<term>   ::= <literal> | <path> | lparen <expr> rparen

<access> ::= <access> lbracket <expr> rbracket
           | <access> dot <ident>
           | <term>

(* Fix this see below. *)

<call>   ::= <assign> <assign>*

(*  Binary operators from lowest precedence to highest 


- Custom token types for unary / sticky operators such as unary but also indices.
*)
<assign> ::= <assign> eq                      <logic>  | <logic>
<ref>    ::=          ref                     <or>     | <or>   
<or>     ::= <or>     pipepipe                <and>    | <and>
<and>    ::= <and>    ampamp                  <eql>    | <eql>
<eql>    ::= <eql>    (eqeq|noteq)            <cmp>    | <cmp>
<cmp>    ::= <cmp>    (gt|lt|gteq|lteq)       <bitor>  | <bitor>
<bitor>  ::= <bitor>  pipe                    <bitxor> | <bitxor>
<bitxor> ::= <bitxor> caret                   <bitand> | <bitand>  
<bitand> ::= <bitand> amp                     <shift>  | <shift>
<shift>  ::= <shift>  (gtgt|ltlt)             <addsub> | <addsub>
<addsub> ::= <addsub> (plus|minus)            <mudimo> | <mumodi>
<mudimo> ::= <mudimo> (star|slash|percent)    <unary>  | <unary>
<unary>  ::=          (bang|minus|tilde|star) <unary>  | <access>


(* Constant pattern *)
<bind>   ::= mut? <ident> | <bind> (comma <bind>)+ | rparen <bind> lparen

<arm>    ::= pipe <type> (as <bind>)? thickarrow <expr>
<match>  ::= match <call> nl (<arm> (nl <arm>)*)*

<let>    ::= let <bind> (colon <type>)? eq <expr>
<loop>   ::= loop <block>


<block>  ::= lbrace nl* (<expr> (nl+ <expr>)*)? nl* rbrace

<expr>   ::= <match> | <let> | <loop> | <call> | <block> | break


(* Decl and Program *)

<generics>   ::= lt <type> (comma <type>)* comma? gt

<type_decl>  ::= type <ident> <generics>? (eq <type>)?

<alias_decl> ::= alias <ident> <generics>? eq <type>

<fn_arg>     ::= lparen <bind> colon <type> rparen

<fn_decl>    ::= fn <ident> <generics>? <fn_arg>* (thinarrow <type>)? <block>

<decl>       ::= <type_decl> | <alias_decl> | <fn_decl>

<program>    ::= nl* <decl> (nl+ <decl>)* nl* eof
